// RUN: zuan-opt -lower-zuan -zuan-stripmining="vf=8 scalable=true" %s \
// RUN: | FileCheck %s

// CHECK-LABEL: func.func @matmul
func.func @matmul(%a: memref<?x?xf32>, %b: memref<?x?xf32>, %c: memref<?x?xf32>) {
  zuan.dynamic (%c : memref<?x?xf32>) {
  ^bb0(%c_tile: !zuan.tile<?x?xf32>):
    %a_tile = zuan.load %a : memref<?x?xf32>
    %b_tile = zuan.load %b : memref<?x?xf32>
    // CHECK: scf.for %[[K:.+]] = %{{.+}} to %{{.+}} step %{{.+}} iter_args(%[[ACC:.+]] = %{{.+}})
    // CHECK: %[[A:.+]] = zuan.load
    // CHECK: %[[B:.+]] = zuan.load
    // CHECK: %[[OUTER:.+]] = zuan.outer <mul> %[[A]], %[[B]]
    // CHECK: %[[NEWACC:.+]] = arith.addf %[[ACC]], %[[OUTER]]
    // CHECK: scf.yield %[[NEWACC]]
    %mm = zuan.matmul %a_tile, %b_tile : !zuan.tile<?x?xf32>, !zuan.tile<?x?xf32>
    %add = arith.addf %mm, %c_tile : !zuan.tile<?x?xf32>
    zuan.yield {
      zuan.store %add, %c : !zuan.tile<?x?xf32>, memref<?x?xf32>
    }
  }
  return
}

// CHECK-LABEL: func.func @matmul2
func.func @matmul2(%a: memref<?x?xf32>, %b: memref<?x?xf32>, %c: memref<?x?xf32>, %d: memref<?x?xf32>) {
  // A @ B @ C
  // CHECK: scf.for
  // CHECK: scf.for
  zuan.dynamic (%d : memref<?x?xf32>) {
  ^bb0(%d_tile: !zuan.tile<?x?xf32>):
    %a_tile = zuan.load %a : memref<?x?xf32>
    %b_tile = zuan.load %b : memref<?x?xf32>
    %c_tile = zuan.load %c : memref<?x?xf32>
    %mm1 = zuan.matmul %a_tile, %b_tile : !zuan.tile<?x?xf32>, !zuan.tile<?x?xf32>
    %mm2 = zuan.matmul %mm1, %c_tile : !zuan.tile<?x?xf32>, !zuan.tile<?x?xf32>
    %add = arith.addf %mm2, %d_tile : !zuan.tile<?x?xf32>
    zuan.yield {
      zuan.store %add, %d : !zuan.tile<?x?xf32>, memref<?x?xf32>
    }
  }
  return
}

// Actually, no need to mask all operations, just make sure load/stores are
// properly masked. Other unmasked and invalid elements generated by matmul
// will be ignored by the store operation.

// CHECK-LABEL: func.func @matmul_masked
func.func @matmul_masked(%a: memref<?x?xf32>, %b: memref<?x?xf32>, %c: memref<?x?xf32>, %m: memref<?x?xi1>) {
  zuan.dynamic (%c : memref<?x?xf32>) {
  ^bb0(%c_tile: !zuan.tile<?x?xf32>):
    %mask = zuan.load %m : memref<?x?xi1>
    %a_tile = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %a_tile = zuan.load %a : memref<?x?xf32>
      zuan.mask_yield %a_tile : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    %b_tile = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %b_tile = zuan.load %b : memref<?x?xf32>
      zuan.mask_yield %b_tile : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>
    
    %mm = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %mm = zuan.matmul %a_tile, %b_tile : !zuan.tile<?x?xf32>, !zuan.tile<?x?xf32>
      zuan.mask_yield %mm : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    %add = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %add = arith.addf %mm, %c_tile : !zuan.tile<?x?xf32>
      zuan.mask_yield %add : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    zuan.yield {
      zuan.mask %mask : !zuan.tile<?x?xi1> {
        zuan.store %add, %c : !zuan.tile<?x?xf32>, memref<?x?xf32>
      }
    }
  }
  return
}

// CHECK-LABEL: func.func @matmul2_masked
func.func @matmul2_masked(%a: memref<?x?xf32>, %b: memref<?x?xf32>, %c: memref<?x?xf32>, %m: memref<?x?xi1>, %d: memref<?x?xf32>) {
  // A @ B @ C
  zuan.dynamic (%d : memref<?x?xf32>) {
  ^bb0(%d_tile: !zuan.tile<?x?xf32>):
    %mask = zuan.load %m : memref<?x?xi1>
    %a_tile = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %a_tile = zuan.load %a : memref<?x?xf32>
      zuan.mask_yield %a_tile : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    %b_tile = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %b_tile = zuan.load %b : memref<?x?xf32>
      zuan.mask_yield %b_tile : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>
    
    %c_tile = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %c_tile = zuan.load %c : memref<?x?xf32>
      zuan.mask_yield %c_tile : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    %mm1 = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %mm1 = zuan.matmul %a_tile, %b_tile : !zuan.tile<?x?xf32>, !zuan.tile<?x?xf32>
      zuan.mask_yield %mm1 : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    %mm2 = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %mm2 = zuan.matmul %mm1, %c_tile : !zuan.tile<?x?xf32>, !zuan.tile<?x?xf32>
      zuan.mask_yield %mm2 : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    %add = zuan.mask %mask : !zuan.tile<?x?xi1> {
      %add = arith.addf %mm2, %d_tile : !zuan.tile<?x?xf32>
      zuan.mask_yield %add : !zuan.tile<?x?xf32>
    } : !zuan.tile<?x?xf32>

    zuan.yield {
      zuan.mask %mask : !zuan.tile<?x?xi1> {
        zuan.store %add, %d : !zuan.tile<?x?xf32>, memref<?x?xf32>
      }
    }
  }
  return
}


